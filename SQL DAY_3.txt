-- Type conversion functions

-- implicit conversion

SELECT 100 +'200' FROM DUAL;

SELECT '01-JAN-2025' FROM DUAL;

SELECT ADD_MONTHS( '01-JAN-2025',3 )FROM DUAL;

SELECT LENGTH(1000) FROM DUAL;

-- EXPLICIT 

SELECT 100+ TO_NUMBER('100') FROM DUAL;

SELECT 100+ TO_NUMBER('100ABC') FROM DUAL; --ERROR

SELECT TO_DATE('10-JANUARY-2025') FROM DUAL;

SELECT TO_DATE('10-10-2025') FROM DUAL; --ERROR

SELECT TO_DATE('10-10-2025','DD-MM-YY') FROM DUAL;

SELECT TO_DATE('12-23-25') FROM DUAL;

SELECT TO_DATE('122325','MMDDYYYY') FROM DUAL;

SELECT CONCAT(TO_CHAR(12345),'HELLO') FROM DUAL;

SELECT SYSDATE FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'DDTH MONTH YYYY') FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'DD MONTH YYYY') FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'DD MONTH YEAR') FROM DUAL;

-----------------------------
--DATE FUNCTION
select round(months_between(sysdate, '01-Jan-25'),2) from dual;

select round(months_between('01-Jan-25',sysdate),2) from dual;

select add_months(sysdate,3) from dual;

select add_months('02/05/2025',3) from dual;

select add_months(to_date('02/05/2025','MM/DD/YYYY'),3) from dual;

SELECT NEXT_DAY(SYSDATE, 'SUNDAY') FROM DUAL;

SELECT LAST_DAY(SYSDATE) FROM DUAL;

--TO FIND A DIFF IN TWO DATES IN TERMS OF MONTHS
SELECT ROUND (months_between(sysdate,'01-Jan-24'),2) from dual;

--to find the diff in two dates in terms number of days
select sysdate - TO_DATE('01-JAN-25') FROM DUAL;

SELECT TRUNC(TO_DATE('31-DEC-24')) FROM DUAL;

SELECT TRUNC(TO_DATE('31-DEC-24'),'MONTH') FROM DUAL;

SELECT TRUNC('31-DEC-24','DD-MON-YY') FROM DUAL;

SELECT TRUNC(TO_DATE('31-DEC-24'),'Q') FROM DUAL;

SELECT extract(day from sysdate) from dual;
select to_number(to_char(sysdate,'dd')) from dual;

select extract (month from sysdate) from dual;
select extract (day from sysdate) from dual;
select extract (year from sysdate) from dual;

select CURRENT_TIMESTAMP FROM DUAL;
SELECT EXTRACT(hour from CURRENT_TIMESTAMP ) as current_hour from dual;
SELECT EXTRACT(minute from CURRENT_TIMESTAMP ) as current_minute from dual;

select trunc(sysdate) from dual;

------------------------------------------
----JOINING MULTIPLE TABLES----
CREATE TABLE DEPT(DEPTNO NUMBER, DNAME VARCHAR2(20),LOC VARCHAR2(20));
CREATE TABLE EMP(EMPNO NUMBER, ENAME VARCHAR2(20),DEPTNO VARCHAR2(20));

INSERT INTO DEPT VALUES(10, 'ACCOUNT', 'T1 10F');
INSERT INTO DEPT VALUES(20, 'AUDIT', 'T2 3F');
INSERT INTO DEPT VALUES(30, 'IT', 'T1 5F');

INSERT INTO EMP VALUES(101, 'AMIT', 10);
INSERT INTO EMP VALUES(102, 'RAGHU', 10);
INSERT INTO EMP VALUES(103, 'SHEETAL', 20);
INSERT INTO EMP VALUES(104, 'RAJU', 40);

SELECT * FROM DEPT;
SELECT * FROM EMP;

----CROSS JOIN----

SELECT * FROM DEPT,EMP; --OLD STYLE JOIN
SELECT * FROM DEPT CROSS JOIN EMP;

-- INNER JOIN --
SELECT * FROM DEPT,EMP WHERE DEPT.DEPTNO=EMP.DEPTNO; --OLD STYLE JOIN
SELECT * FROM DEPT NATURAL JOIN EMP; --NATURAL JOIN IS ONE WAY OF IMPLEMENTING INNER JOIN 
SELECT * FROM DEPT JOIN EMP ON DEPT.DEPTNO= EMP.DEPTNO; --JOIN WITH ON CLAUSE
SELECT * FROM DEPT JOIN EMP USING(DEPTNO); 				-- JOIN WITH USING CLAUSE

ALTER TABLE EMP RENAME COLUMN DEPTNO TO DEPTID;
DESC EMP;
DESC DEPT;

SELECT * FROM DEPT NATURAL JOIN EMP;   -- NATURAL JOIN BEHAVES AS A CROSS JOIN IF THERE IS NO  COMMON COLOUMN
SELECT * FROM DEPT,EMP WHERE DEPT.DEPTNO=EMP.DEPTID; -- STILL WORKS (WITH UPDATED COLUMN NAMES)
SELECT * FROM DEPT JOIN EMP USING(DEPTNO); -- NOT POSSIBLE THIS TIME 

--USE INNER KEYWORD
SELECT * FROM DEPT INNER JOIN EMP ON DEPT.DEPTNO=EMP.DEPTID; -- USING A INNER KEYWORD IS NOT MANDATORY

-- USING ALIAS AND SELECTING SPECIFIC COLUMNS
SELECT D.DEPTNO, D.DNAME, D.LOC, E.EMPNO, E.ENAME FROM DEPT D INNER JOIN EMP E ON D.DEPTNO=E.DEPTID;

--OUTER JOIN
--LEFT OUTER JOIN
SELECT * FROM DEPT LEFT JOIN EMP ON DEPT.DEPTNO=EMP.DEPTID;
SELECT * FROM DEPT LEFT OUTER JOIN EMP ON DEPT.DEPTNO=EMP.DEPTID;

--RIGHT OUTER JOIN
SELECT * FROM DEPT RIGHT JOIN EMP ON DEPT.DEPTNO=EMP.DEPTID;
SELECT * FROM DEPT RIGHT OUTER JOIN EMP ON DEPT.DEPTNO=EMP.DEPTID;

--FULL OUTER JOIN
SELECT * FROM DEPT FULL JOIN EMP ON DEPT.DEPTNO=EMP.DEPTID;
SELECT * FROM DEPT FULL OUTER JOIN EMP ON DEPT.DEPTNO=EMP.DEPTID;


--- SELF JOIN
SELECT * FROM SCOTT.EMP;

SELECT WORKER.ENAME ||'WORKS FOR' || MANAGER.ENAME FROM SCOTT.EMP  WORKER JOIN SCOTT.EMP MANAGER ON  WORKER.MGR = MANAGER.EMPNO; 

-- WHICH EMPLOYEE WORS FOR WHICH MANAGER
SELECT WORKER.ENAME || ' WORKS FOR ' || MANAGER.ENAME
FROM SCOTT.EMP WORKER JOIN SCOTT.EMP MANAGER
ON WORKER.MGR = MANAGER.EMPNO

--WHICH EMPLOYESS ARE GETTING SAL MORE THAN THEIR MANAGERS
SELECT WORKER.ENAME || ' WORKS FOR ' || MANAGER.ENAME
FROM SCOTT.EMP WORKER JOIN SCOTT.EMP MANAGER
ON WORKER.MGR = MANAGER.EMPNO AND WORKER.SAL>MANAGER.SAL;

--------------------------------------------
-- ANALYTICAL FUNCTIONS

SELECT EMPNO, DEPTNO, SAL,
    		ROW_NUMBER() OVER(ORDER BY SAL) AS RN,
            RANK() OVER(ORDER BY SAL) AS RNK,
    		DENSE_RANK() OVER(ORDER BY SAL) AS DNS_RNK
FROM SCOTT.EMP;

SELECT EMPNO, DEPTNO, SAL,
    		ROW_NUMBER() OVER(ORDER BY SAL DESC) AS RN,
            RANK() OVER(ORDER BY SAL DESC) AS RNK,
    		DENSE_RANK() OVER(ORDER BY SAL DESC) AS DNS_RNK
FROM SCOTT.EMP;

SELECT EMPNO, DEPTNO, SAL, ROW_NUMBER() OVER(PARTITION BY DEPTNO ORDER BY SAL DESC) AS RN FROM SCOTT.EMP

SELECT DEPTNO, LISTAGG(ENAME, ',')  FROM SCOTT.EMP GROUP BY DEPTNO;    
SELECT DEPTNO, LISTAGG(ENAME, ',') WITHIN GROUP (ORDER BY ENAME) FROM SCOTT.EMP GROUP BY DEPTNO;

SELECT ENAME, SAL, DEPTNO, 
      FIRST_VALUE(ENAME) OVER(ORDER BY SAL) AS PERSON_WITH_LOWEST_SAL FROM SCOTT.EMP

SELECT ENAME, SAL, DEPTNO, 
      FIRST_VALUE(ENAME) OVER(ORDER BY SAL DESC) AS PERSON_WITH_HIGHEST_SAL FROM SCOTT.EMP

SELECT ENAME, SAL, DEPTNO, 
      FIRST_VALUE(ENAME) OVER(PARTITION BY DEPTNO ORDER BY SAL) AS PERSON_WITH_LOWEST_SAL FROM SCOTT.EMP

---LAST VALUE()
SELECT ENAME, SAL, DEPTNO, 
      LAST_VALUE(ENAME) OVER(ORDER BY SAL RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) 
      AS PERSON_WITH_LOWEST_SAL FROM SCOTT.EMP;


-- LEAD AND LAG 
CREATE TABLE SALES(SALES_ID NUMBER, SALES_YEAR NUMBER, SALES_AMOUNT NUMBER);
INSERT INTO SALES VALUES(1001,2015,10500);
INSERT INTO SALES VALUES(1002,2016,11500);
INSERT INTO SALES VALUES(1003,2017,12000);
INSERT INTO SALES VALUES(1004,2018,14000);
INSERT INTO SALES VALUES(1005,2019,16000);
INSERT INTO SALES VALUES(1006,2020,15000);
INSERT INTO SALES VALUES(1007,2021,14500);
INSERT INTO SALES VALUES(1008,2022,17000);
INSERT INTO SALES VALUES(1009,2023,18000);
INSERT INTO SALES VALUES(1010,2024,20000);

SELECT SALES.*, LEAD(SALES_AMOUNT) OVER(ORDER BY SALES_YEAR) AS NEXT_YEAR_SALES FROM SALES;

SELECT SALES.*, LEAD(SALES_AMOUNT) OVER(ORDER BY SALES_YEAR) AS PREV_YEAR_SALES FROM SALES;

SELECT SALES.*, LEAD(SALES_AMOUNT) OVER(ORDER BY SALES_YEAR) AS PREV_YEAR_SALES FROM SALES;

SELECT SALES.*, 
    LEAD(SALES_AMOUNT) OVER(ORDER BY SALES_YEAR) AS NEXT_YEAR_SALES, 
    LEAD(SALES_AMOUNT,2) OVER(ORDER BY SALES_YEAR) AS NEXT_TO_NEXT_YEAR_SALES 
FROM SALES;

SELECT SALES.*, 
    LEAD(SALES_AMOUNT, 1,0) OVER(ORDER BY SALES_YEAR) AS PREV_YEAR_SALES, 
    LEAD(SALES_AMOUNT,2,0) OVER(ORDER BY SALES_YEAR) AS PREV_TO_PREV_YEAR_SALES 
FROM SALES;

SELECT SALES.*, 
    LAG(SALES_AMOUNT, 1,0) OVER(ORDER BY SALES_YEAR) AS PREV_YEAR_SALES, 
    LAG(SALES_AMOUNT,2,0) OVER(ORDER BY SALES_YEAR) AS PREV_TO_PREV_YEAR_SALES 
FROM SALES;


--=======================================================================
-- GROUP FUNCTIONS:
    --COUNT(), SUM(), MIN(), MAX(), AVG(), STDDEV(), VARIANCE()
-- GROUP BY CLAUSE
--- HAVING CLAUSE

SELECT SUM(SAL) FROM SCOTT.EMP;
SELECT MIN(SAL) FROM SCOTT.EMP;
SELECT MAX(SAL) FROM SCOTT.EMP;
SELECT ROUND(AVG(SAL),2) FROM SCOTT.EMP;
SELECT COUNT(SAL) FROM SCOTT.EMP;
SELECT ROUND(VARIANCE(SAL),2) FROM SCOTT.EMP;
SELECT ROUND(STDDEV(SAL),2) FROM SCOTT.EMP;

SELECT DEPTNO, SUM(SAL) FROM SCOTT.EMP GROUP BY DEPTNO;

SELECT ENAME, DEPTNO,  SUM(SAL) FROM SCOTT.EMP GROUP BY DEPTNO;

--RULE:
   --COLUMN WHICH IS USED IN GROUP BY CLAUSE CAN ONLY COME IN SELECT CLAUSE WITHOUT AGGREGATION

-- GROUP BY MULTIPLE COLUMNS
SELECT DEPTNO, JOB, SUM(SAL), COUNT(*) FROM SCOTT.EMP GROUP BY DEPTNO, JOB;

-- DISPLAY THE TOTAL SALARY PAID TO THE EMPLOYESS OF THE DEPARTMENT 10
SELECT SUM(SAL) FROM SCOTT.EMP WHERE DEPTNO=10;

-- VERIFY ABOVE RESULT
SELECT SUM(SAL) FROM SCOTT.EMP GROUP BY DEPTNO;

-- DISPLAY THE DEPARTMENT WISE AVG SAL FOR THE DEPARTMENTS WHERE AVG IS MORE THAN 2000

SELECT DEPTNO, AVG(SAL) FROM SCOTT.EMP WHERE AVG(SAL)>2000;-- error

SELECT DEPTNO, AVG(SAL) FROM SCOTT.EMP GROUP BY DEPTNO HAVING AVG(SAL)>2000;

-- WHILE WRITING SELECT QUERY:
	-- SELECT --> FILTER IN THE COLUMNS
	-- FROM   --> SPECIFY TABLE/S TO RETRIEVE THE DATA FROM
	-- WHERE  -->  FILTER INDIVIDUAL ROWS/RECORDS/TUPLES
	-- GROUP BY --> PREPARE GROUPS OF THE DATA ON THE BASIS OF ONE OR MORE COLUMNS
	-- HAVING  --> FILTER THE GROUPS PREPARED IN THE GROUP BY CLAUSE
	-- ORDER BY --> SQRT THE DATA WHILE DISPLAYING (AP ER ONE OR MORE COLUMNS, IN ASC OR DESC ORDER)
--WHILE EXECUTING SELECT QUERY:
   --FROM --> WHERE --> GROUP BY --> HAVING --> SELECT ---> ORDER BY 

SELECT SUM(SAL) FROM SCOTT.EMP GROUP BY DEPTNO;

SELECT SUM(SAL) AS TOTAL_SAL FROM SCOTT.EMP GROUP BY DEPTNO HAVING TOTAL_SAL>10000;

SELECT SUM(SAL) AS TOTAL_SAL FROM SCOTT.EMP GROUP BY DEPTNO ORDER BY TOTAL_SAL;

SELECT SUM(SAL) AS TOTAL_SAL FROM SCOTT.EMP GROUP BY DEPTNO ORDER BY TOTAL_SAL DESC;

--get the department wise total salary for the employess who joined in the year of 1981

SELECT DEPTNO, SUM(SAL), COUNT(*) FROM SCOTT.EMP WHERE HIREDATE < '01-JAN-82' GROUP BY DEPTNO;

SELECT * FROM SCOTT.EMP WHERE HIREDATE< '01-JAN-82';

SELECT DEPTNO, SUM(SAL), COUNT(*) 
    FROM SCOTT.EMP WHERE HIREDATE BETWEEN '01-JAN-82' AND '31-DEC-81' GROUP BY DEPTNO;  

SELECT DEPTNO, SUM(SAL), COUNT(*) 
    FROM SCOTT.EMP WHERE HIREDATE BETWEEN '01-JAN-82' AND '31-DEC-81';

---ROWNUM
SELECT * FROM SCOTT.EMP WHERE ROWNUM<5;

SELECT * FROM SCOTT.EMP WHERE ROWNUM<=6;

--DISPLAY THE DETAILS OF TOP 3 EMPLOYESS SALARY WISE

SELECT * FROM SCOTT.EMP ORDER BY SAL FETCH FIRST 3 ROWS ONLY;

SELECT ENAME FROM SCOTT.EMP WHERE INSTR(UPPER(ENAME), 'A') > 0;

SELECT TO_CHAR(DEPTNO) || '_' || TO_CHAR(EMPNO) AS deptid_empid 
FROM SCOTT.EMP;

SELECT SUBSTR(ENAME, -3) AS last_3_chars FROM SCOTT.EMP WHERE DEPTNO = 20;

SELECT ENAME, NVL2(MGR, 'has a Manager', 'do not have a Manager') AS Manager_Status FROM SCOTT.EMP;

SELECT 
    empno, 
    ename, 
    sal, 
    NVL(
        DECODE(
            TRUE,
            sal < 1000, 'poor sal',
            sal < 2000, 'just okay',
            sal < 3000, 'Good sal',
            'Big Shots'
        ), 'Unknown'
    ) AS sal_comment
FROM 
    scott.emp;




